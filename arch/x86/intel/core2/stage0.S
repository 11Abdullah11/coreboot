/* 
 * This file is part of the coreboot project.
 * 
 * Copyright (C) 2000,2007 Ronald G. Minnich <rminnich@gmail.com>
 * Copyright (C) 2007-2008 coresystems GmbH
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#define ASSEMBLY
#define CACHE_AS_RAM_SIZE CONFIG_CARSIZE
#define CACHE_AS_RAM_BASE CONFIG_CARBASE

#define XIP_ROM_BASE 0xfff00000
#define XIP_ROM_SIZE 0x00100000

#include <mtrr.h>

#include <macros.h>

#define ROM_CODE_SEG 0x08
#define ROM_DATA_SEG 0x10

#define CACHE_RAM_CODE_SEG 0x18
#define CACHE_RAM_DATA_SEG 0x20

	/* When we come here we are in protected mode. We expand the stack
	 * and copy the data segment from ROM to the memory.
	 *
	 * After that, we call the chipset bootstrap routine that
	 * does what is left of the chipset initialization.
	 *
	 * NOTE: Aligned to 4 so that we are sure that the prefetch
	 * cache will be reloaded.
	 */

	.align  4
	.globl protected_stage0
protected_stage0:
	/* This code was used by v2. TODO. */
	lgdt	%cs:gdtptr
	ljmp	$ROM_CODE_SEG, $__protected_stage0

.globl __protected_stage0
__protected_stage0:
	/* Save the BIST result. */
	movl	%eax, %ebp

	port80_post(0x01)

	movw	$ROM_DATA_SEG, %ax
	movw	%ax, %ds
	movw	%ax, %es
	movw	%ax, %ss
	movw	%ax, %fs
	movw	%ax, %gs

cache_as_ram:

	port80_post(0x20)

	/* Send INIT IPI to all excluding ourself */
        movl	$0x000C4500, %eax
        movl	$0xFEE00300, %esi
        movl	%eax, (%esi)

	/* Zero out all Fixed Range and Variable Range MTRRs */
	movl	$mtrr_table, %esi
	movl	$( (mtrr_table_end - mtrr_table) / 2), %edi
	xorl    %eax, %eax
	xorl    %edx, %edx
clear_mtrrs:
	movw    (%esi), %bx
	movzx   %bx, %ecx
	wrmsr
	add	$2, %esi
	dec	%edi
	jnz	clear_mtrrs

	/* Configure the default memory type to uncacheable */
	movl	$MTRRdefType_MSR, %ecx
	rdmsr
	andl	$(~0x00000cff), %eax
	wrmsr

	/* Set cache as ram base address */
	movl	$(MTRRphysBase_MSR(0)), %ecx
	movl	$(CACHE_AS_RAM_BASE | MTRR_TYPE_WRBACK), %eax
	xorl	%edx, %edx
	wrmsr

	/* Set cache as ram mask */
	movl	$(MTRRphysMask_MSR(0)), %ecx
	movl	$(~((CACHE_AS_RAM_SIZE-1)) | (1 << 11)), %eax
	movl	$0x0000000f, %edx
	wrmsr

	/* Enable MTRR */
	movl	$MTRRdefType_MSR, %ecx
	rdmsr
	orl	$(1 << 11), %eax
	wrmsr

	/* Enable L2 Cache */
	movl	$0x11e, %ecx
	rdmsr
	orl	$(1 << 8), %eax
	wrmsr

	/* CR0.CD = 0, CR0.NW = 0 */
        movl	%cr0, %eax
	andl	$( ~( (1 << 30) | (1 << 29) ) ), %eax
	invd
	movl	%eax, %cr0

	/* Clear the cache memory reagion */
	movl	$CACHE_AS_RAM_BASE, %esi
	movl	%esi, %edi
	movl	$(CACHE_AS_RAM_SIZE / 4), %ecx
	//movl	$0x23322332, %eax
	xorl	%eax, %eax
	rep	stosl

	/* Enable Cache As RAM mode by disabling cache */
	movl	%cr0, %eax
	orl	$(1 << 30), %eax
	movl	%eax, %cr0

#if defined(XIP_ROM_SIZE) && defined(XIP_ROM_BASE)
	/* Enable cache for our code in Flash because we do XIP here */
        movl    $MTRRphysBase_MSR(1), %ecx
        xorl    %edx, %edx
        movl    $(XIP_ROM_BASE | MTRR_TYPE_WRBACK), %eax
        wrmsr

        movl    $MTRRphysMask_MSR(1), %ecx
        movl    $0x0000000f, %edx
        movl    $(~(XIP_ROM_SIZE - 1) | 0x800), %eax
        wrmsr
#endif /* XIP_ROM_SIZE && XIP_ROM_BASE */

        /* enable cache */
        movl	%cr0, %eax
	andl	$( ~( (1 << 30) | (1 << 29) ) ), %eax
        movl	%eax, %cr0

	/* Set up stack pointer */
	movl	$(CACHE_AS_RAM_BASE + CACHE_AS_RAM_SIZE - 4), %eax
	movl	%eax, %esp

	/* Third parameter: cpu #: 0 == BSP all other are APs.
	 * 0 until SMP support is added.
	 */
	pushl	$0
	/* Second parameter: init_detected */
	/* Store zero for the unused init_detected parameter. */
	pushl	$0
	/* First parameter: bist */
	/* Restore the BIST result */
	movl	%ebp, %eax
	movl	%esp, %ebp
	pushl	%eax


#if 0
	/* this will be interpreted as failed bist */
	port80_post(0x23)
#endif


	call	stage1_phase1

	port80_post(0x2f)
error:
	hlt
	jmp	error

mtrr_table:
	/* Fixed MTRRs */
        .word 0x250, 0x258, 0x259
        .word 0x268, 0x269, 0x26A
        .word 0x26B, 0x26C, 0x26D
        .word 0x26E, 0x26F
	/* Variable MTRRs */
        .word 0x200, 0x201, 0x202, 0x203
        .word 0x204, 0x205, 0x206, 0x207
        .word 0x208, 0x209, 0x20A, 0x20B
        .word 0x20C, 0x20D, 0x20E, 0x20F
mtrr_table_end:


#include "../../stage0_common.S"
